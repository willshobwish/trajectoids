from compute_trajectoid_in_colab import *
from bisect import bisect_left
from scipy.interpolate import interp1d
# %matplotlib inline
#@markdown # <-- Press this "Play" button after you've selected the parameters below
#@markdown ### Here you select you path:
#@markdown If you want it to be based on your drawing, select "drawing". If you supplied a CSV file with a list of X,Y coordinates (see above), select "csv file". Otherwise, path will be randomly generated by default.
source_of_path = 'randomly generated' #@param ["csv file", "drawing", "randomly generated"]

# csv_filename = 'path_coordinates.csv'

#@markdown ### Optional settings (you may leave these at default values)
#@markdown When this checkbox is selected, relative scale of path and its trajectoid will be searched automatically.
auto_scale_range = True #@param {type:"boolean"}

#@markdown If `auto_scale_range` parameter is not checked, the following will be the minimum and maximum values of the scales. Only one trajectoid solution must lie between them.
manual_scale_min = 0.5 #@param {type:"number"}
manual_scale_max = 0.7 #@param {type:"number"}

#@markdown If you choose to generate random path, this number will be used as seed for the random number generator. Change it to get different paths.
random_seed = 0 #@param {type:"number"}

def plot_gb_areas(ax, sweeped_scales, gb_areas, mark_one_scale, scale_to_mark, length_of_path, x_limit_of_curve=None):
    ii = np.searchsorted(sweeped_scales, scale_to_mark)
    gb_areas = np.insert(gb_areas, ii, np.pi * np.sign(interpolate.interp1d(sweeped_scales, gb_areas)(scale_to_mark)))
    sweeped_scales = np.insert(sweeped_scales, ii, scale_to_mark)
    xfactor = length_of_path/(2*np.pi)
    if x_limit_of_curve is None:
        ax.plot(sweeped_scales * xfactor, gb_areas)
    else:
        last_index = bisect_left(sweeped_scales, x_limit_of_curve)
        ax.plot(sweeped_scales[:last_index] * xfactor, gb_areas[:last_index])
    ax.axhline(y=np.pi, color='black', alpha=0.5)
    ax.axhline(y=0, color='black', alpha=0.3)
    ax.axhline(y=-1 * np.pi, color='black', alpha=0.5)
    if mark_one_scale:
        value_at_scale_to_mark = interp1d(sweeped_scales, gb_areas, fill_value='extrapolate')(scale_to_mark)
        ax.scatter([scale_to_mark * xfactor], [value_at_scale_to_mark], s=20, color='red')
    ax.set_yticks([-2 * np.pi, -np.pi, 0, np.pi, 2 * np.pi])
    ax.set_yticklabels(['-2π', '-π', '0', 'π', '2π'])
    ax.set_ylim(-np.pi * 2 * 1.01, np.pi * 2 * 1.01)
    ax.set_ylabel('Norm. spherical\narea $S(r)/r^2$')
    ax.set_xlabel('Path\'s scale $\sigma = L/(2 \pi r)$')



target_folder = 'test'
if source_of_path == 'randomly generated':
    input_path_single_section = make_random_path(seed=random_seed, make_ends_horizontal=False,
                                             start_from_zero=True,
                                             end_with_zero=True, amplitude=3)
elif source_of_path == 'drawing':
    input_path_single_section = get_trajectory_from_raster_image('my_drawing.png',
                                                                 do_plotting=False)
    plt.plot(input_path_single_section[:, 0], input_path_single_section[:, 1],
             color='black')
    plt.axis('equal')
    plt.xlabel('X coordinate')
    plt.ylabel('Y coordinate')
    plt.title('Path obtained from your drawing')
    plt.show()
# elif source_of_path == 'csv file':
#     input_path_single_section = np.genfromtxt(csv_filename, delimiter=',')
#     xs = input_path_single_section[:, 0]
#     ys = input_path_single_section[:, 1]
#     xs = xs - xs[0]
#     ys = ys - ys[0]
#     ys = ys - xs * (ys[-1] - ys[0]) / (xs[-1] - xs[0])
#     input_path_single_section[:, 0] = xs
#     input_path_single_section[:, 1] = ys
#     plt.plot(input_path_single_section[:, 0], input_path_single_section[:, 1],
#              color='black')
#     plt.axis('equal')
#     plt.xlabel('X coordinate')
#     plt.ylabel('Y coordinate')
#     plt.title('Path obtained from your CSV file')
#     plt.show()

input_path_0 = double_the_path(input_path_single_section, do_plot=False)

do_plot = True
minscale = 0.01
#@markdown Maximum scale attempted by automatic search. Increase only if error indicates so.
upper_limit_of_auto_search = 10 # @param {type:"number"}
nframes = 300

fig, ax = plt.subplots()

sweeped_scales, gb_areas = gb_areas_for_all_scales(input_path_single_section,
                                                   minscale=minscale, maxscale=upper_limit_of_auto_search,
                                                    nframes=nframes, adaptive_sampling=True)
if auto_scale_range:
    print('Automatic search for scale factor...')
    index_where_area_crosses_pi = np.argmax(np.abs(gb_areas) > np.pi)
    if index_where_area_crosses_pi == 0:
        print('Automatic range of scales is too short. Increase the upper limit.')
    range_for_searching_the_roots = [sweeped_scales[index_where_area_crosses_pi - 2],
                                      sweeped_scales[index_where_area_crosses_pi + 1]]
    best_scale = minimize_mismatch_by_scaling(input_path_0, scale_range=range_for_searching_the_roots)
    if not best_scale:
        print('Range of scales is wrong. Try manual range instead of auto.')
    length_of_path = length_of_the_path(input_path_single_section)
    plot_gb_areas(ax, sweeped_scales, gb_areas, mark_one_scale=True,
                          scale_to_mark=best_scale, length_of_path=length_of_path)

else:
    best_scale = minimize_mismatch_by_scaling(input_path_0,
                                              scale_range=[manual_scale_min, manual_scale_max])

print(f'Scale factor σ=L/2πr that yields trajectoid: {best_scale * length_of_path/(2*np.pi)}')

input_path = best_scale * input_path_0

# fig2 = plt.figure(2)
plot_three_path_periods(input_path, plot_midpoints=True, savetofile=os.path.join(target_folder,'input_path'))
plt.gca().set_title('Several periods of the target path')

## Make cut meshes for trajectoid
compute_shape(input_path, kx=1, ky=1,
              folder_for_path=os.path.join(target_folder,'folder_for_path'),
              folder_for_meshes=os.path.join(target_folder,'cut_meshes'),
              core_radius=1, cut_size = 10)

number_of_boxes = input_path.shape[0]
print(number_of_boxes)
print("Execution finished.")